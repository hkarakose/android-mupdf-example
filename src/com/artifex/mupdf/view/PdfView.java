package com.artifex.mupdf.view;

import android.content.Context;
import android.graphics.Bitmap;
import android.graphics.Point;
import android.graphics.PointF;
import android.graphics.Rect;
import android.net.Uri;
import android.util.AttributeSet;
import android.util.Log;
import android.widget.FrameLayout;
import android.widget.ImageView;
import android.widget.RelativeLayout;
import android.widget.VideoView;
import com.artifex.mupdf.AsyncTask;
import com.artifex.mupdf.BitmapHolder;
import com.artifex.mupdf.MuPDFCore;
import com.example.mupdf.R;

import static android.view.ViewGroup.LayoutParams.*;

/**
 * User: Halil Karakose
 * Date: 7/31/14
 * Time: 6:11 PM
 */
public class PdfView extends RelativeLayout {
    private static final String TAG = PdfView.class.getSimpleName();

    private Context context;
    private ImageView imageView;
    private MuPDFCore core;

    private FrameLayout videoFrame;
    private VideoView videoView;

    private Point parentViewSize;
    private PointF pdfSize;
    private Point size;   // Size of page at minimum zoom
    float sourceScale;

    private Rect mPatchArea = null;
    private Point mPatchViewSize = null;
    private BitmapHolder mPatchBmh = new BitmapHolder();

    private int pageNumber;

    public PdfView(final Context context, MuPDFCore core, Point parentSize, int position) {
        this(context);

        this.context = context;
        this.core = core;

        this.imageView = new ImageView(context);
        imageView.setImageResource(R.drawable.ic_launcher);
        imageView.setScaleType(ImageView.ScaleType.FIT_CENTER);
        addView(imageView);
        ;
        parentViewSize = parentSize;
        this.pageNumber = position;
        pdfSize = core.getPageSize(pageNumber);
        sourceScale = Math.min(parentViewSize.x / pdfSize.x, parentViewSize.y / pdfSize.y);
        size = new Point((int) (pdfSize.x * sourceScale), (int) (pdfSize.y * sourceScale));

        int width = parentViewSize.x;
        int height = parentViewSize.y;
        int patchWidth = parentViewSize.x;
        int patchHeight = parentViewSize.y;
        Bitmap bitmap = core.drawPage(position, width, height, 0, 0, patchWidth, patchHeight);
        imageView.setImageBitmap(bitmap);

        videoView = new VideoView(context);
        videoFrame = new FrameLayout(context);
        videoFrame.addView(videoView, MATCH_PARENT, MATCH_PARENT);

        LayoutParams params = new LayoutParams(600, 340);
        params.setMargins(100, 340, 0, 0);
        addView(videoFrame, params);
    }

    @Override
    protected void onLayout(boolean changed, int left, int top, int right, int bottom) {
        Log.i(TAG, "onlayout: left: " + left + ", top: " + top);
        super.onLayout(changed, left, top, right, bottom);

        int w = right - left;
        int h = bottom - top;

        imageView.layout(0, 0, w, h);
    }

    private AsyncTask<PatchInfo, Void, PatchInfo> drawPatchTask;
    Rect viewArea = new Rect(0, 0, 0, 0);

    public void addHq(boolean update) {
        viewArea = new Rect(getLeft(), getTop(), getRight(), getBottom());
        // If the viewArea's size matches the unzoomed size, there is no need for an hq patch
        if (viewArea.width() != size.x || viewArea.height() != size.y) {
            Point patchViewSize = new Point(viewArea.width(), viewArea.height());
            Rect patchArea = new Rect(0, 0, parentViewSize.x, parentViewSize.y);

            // Intersect and test that there is an intersection
            if (!patchArea.intersect(viewArea))
                return;

            // Offset patch area to be relative to the view top left
            Log.d(TAG, "offset width: " + -viewArea.left + "offset height: " + -viewArea.top);
            patchArea.offset(-viewArea.left, -viewArea.top);

            boolean area_unchanged = patchArea.equals(mPatchArea) && patchViewSize.equals(mPatchViewSize);

            // If being asked for the same area as last time, nothing to do
            if (area_unchanged && !update)
                return;

            boolean completeRedraw = !(area_unchanged && update);

            // Stop the drawing of previous patch if still going
            if (drawPatchTask != null) {
                Log.d(TAG, "cancel drawPatchTask task");
                drawPatchTask.cancel(true);
                drawPatchTask = null;
            }

            if (completeRedraw) {
                // The bitmap holder mPatchBm may still be rendered to by a
                // previously invoked task, and possibly for a different
                // area, so we cannot risk the bitmap generated by this task
                // being passed to it
                mPatchBmh.drop();
                mPatchBmh = new BitmapHolder();
            }

            System.gc();

            drawPatchTask = new AsyncTask<PatchInfo, Void, PatchInfo>() {
                protected PatchInfo doInBackground(PatchInfo... v) {
                    PatchInfo info = v[0];
                    if (info.completeRedraw) {
                        info.setBm(core.drawPage(pageNumber, info.patchViewSize.x, info.patchViewSize.y,
                                info.patchArea.left, info.patchArea.top,
                                info.patchArea.width(), info.patchArea.height()));
                    } else {
                        info.setBm(core.updatePage(info.bmh, pageNumber, info.patchViewSize.x, info.patchViewSize.y,
                                info.patchArea.left, info.patchArea.top,
                                info.patchArea.width(), info.patchArea.height()));
                    }

                    return info;
                }

                protected void onPostExecute(PatchInfo info) {
                    mPatchViewSize = info.patchViewSize;
                    mPatchArea = info.patchArea;
                    if (info.getBm() != null) {
                        imageView.setImageBitmap(info.getBm());
                        info.setBm(null);
                    }
                    requestLayout();
                    // Calling requestLayout here doesn't lead to a later call to layout. No idea
                    // why, but apparently others have run into the problem.
                    imageView.layout(mPatchArea.left, mPatchArea.top, mPatchArea.right, mPatchArea.bottom);
                    invalidate();
                }
            };

            drawPatchTask.execute(new PatchInfo(patchViewSize, patchArea, mPatchBmh, completeRedraw));
        }
    }

    public void play() {
        videoView.setVideoURI(Uri.parse("android.resource://" + context.getPackageName() + "/" + R.raw.samplei));
        videoView.start();
    }

    public PdfView(Context context) {
        super(context);
    }

    public PdfView(Context context, AttributeSet attrs) {
        super(context, attrs);
    }

    public PdfView(Context context, AttributeSet attrs, int defStyle) {
        super(context, attrs, defStyle);
    }
}
